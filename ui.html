<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Figma プラグイン: マスク画像取得</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 16px;
      }
      .section {
        margin-bottom: 24px;
      }
      .section h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
      }
      .controls {
        margin-bottom: 12px;
      }
      .control-group {
        margin-bottom: 8px;
      }
      .control-group label {
        display: inline-block;
        width: 60px;
      }
      .control-group input[type="number"] {
        width: 60px;
        margin: 0 4px;
      }
      .control-group input[type="range"] {
        width: 120px;
        margin: 0 8px;
      }
      .canvas-container {
        position: relative;
      }
      #compositePreview {
        border: 1px solid #ccc;
        max-width: 100%;
        background: #f0f0f0;
        cursor: move;
      }
      .canvas-hint {
        position: absolute;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
      }
      .recording-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .primary-button {
        background: #18a0fb;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
      }
      .primary-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .secondary-button {
        background: white;
        color: #333;
        border: 1px solid #ccc;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
      }
      .secondary-button:disabled {
        color: #999;
        cursor: not-allowed;
      }
      .status-text {
        color: #666;
        font-size: 14px;
      }
      .recording .status-text {
        color: #f00;
      }
    </style>
  </head>
  <body>
    <h2>Figma プラグイン: マスク画像＋動画合成</h2>
    <div class="section">
      <h3>1. 素材選択</h3>
      <div class="materials">
        <button id="getMaskImage" class="material-button">
          マスク画像を選択<span class="material-status" id="maskStatus"
            >未選択</span
          >
        </button>
        <label class="material-button" for="videoUpload">
          動画を選択
          <span class="material-status" id="videoStatus">未選択</span>
        </label>
        <input
          type="file"
          id="videoUpload"
          accept="video/webm,video/mp4"
          hidden
        />
      </div>
    </div>

    <div class="section">
      <h3>2. 合成プレビュー</h3>
      <div class="controls">
        <div class="control-group">
          <label>スケール: </label>
          <input
            type="range"
            id="scale"
            min="0.1"
            max="2"
            step="0.1"
            value="1"
          />
          <span id="scaleValue">1.0</span>
        </div>
      </div>
      <div class="canvas-container">
        <canvas id="compositePreview"></canvas>
        <div class="canvas-hint">動画をドラッグして位置を調整できます</div>
      </div>
    </div>

    <div class="section">
      <h3>4. 録画</h3>
      <div class="recording-controls">
        <button id="startRecording" class="primary-button">録画開始</button>
        <button id="stopRecording" class="secondary-button" disabled>
          手動停止
        </button>
        <div id="recordingStatus" class="status-text"></div>
      </div>
    </div>

    <script>
      // マスク画像取得
      document.getElementById("getMaskImage").onclick = () => {
        parent.postMessage({ pluginMessage: { type: "get-mask-image" } }, "*");
      };
      // Figmaからのメッセージ処理
      window.onmessage = (event) => {
        const msg = event.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "mask-image") {
          const blob = new Blob([new Uint8Array(msg.data)], {
            type: "image/png",
          });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.onload = () => {
            maskImage = img;
            updateMaskStatus(true);
            updateCanvasSize();
          };
          img.src = url;
        } else if (msg.type === "error") {
          alert(msg.message);
        }
      };

      // 合成プレビューの状態管理
      let maskImage = null;
      let videoElement = null;
      const canvas = document.getElementById("compositePreview");
      const ctx = canvas.getContext("2d");
      let posX = 0;
      let posY = 0;
      let scale = 1;

      // キャンバスサイズの設定
      function updateCanvasSize() {
        if (!maskImage) return;
        canvas.width = maskImage.width;
        canvas.height = maskImage.height;
        drawComposite();
      }

      // 合成描画
      function drawComposite() {
        // キャンバスが初期化されていない場合は初期化
        if (!canvas.width || !canvas.height) {
          if (maskImage) {
            canvas.width = maskImage.width;
            canvas.height = maskImage.height;
          } else if (videoElement) {
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
          } else {
            return; // どちらの素材もない場合は何もしない
          }
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 下層に動画を描画（もしあれば）
        if (videoElement && videoElement.readyState >= 2) {
          // HAVE_CURRENT_DATA以上
          ctx.save();
          ctx.translate(posX, posY);
          ctx.scale(scale, scale);
          ctx.drawImage(videoElement, 0, 0);
          ctx.restore();
        }

        // 上層にマスク画像を描画（もしあれば）
        if (maskImage) {
          ctx.drawImage(maskImage, 0, 0);
        }
      }

      // 動画ファイルアップロード処理
      document.getElementById("videoUpload").onchange = (event) => {
        const file = event.target.files[0];
        if (!file) {
          updateVideoStatus(false);
          videoElement = null;
          return;
        }

        // 動画ファイルの形式チェック
        if (!file.type.match("video/(webm|mp4)")) {
          alert("WebMまたはMP4形式の動画ファイルを選択してください。");
          updateVideoStatus(false);
          return;
        }

        const url = URL.createObjectURL(file);
        const video = document.createElement("video");
        video.src = url;

        // 必要な属性を設定
        video.autoplay = false;
        video.loop = true;
        video.muted = true;

        // 合成プレビュー用の参照を保存
        videoElement = video;

        // メタデータ読み込み完了時の処理
        video.onloadeddata = async () => {
          updateVideoStatus(true);
          // 最初のフレームを表示するために一時的に再生
          await video.play();
          video.pause();
          drawComposite();
        };

        // 再生時の更新処理
        video.addEventListener("play", () => {
          function updateCanvas() {
            if (!video.paused && !video.ended) {
              drawComposite();
              requestAnimationFrame(updateCanvas);
            }
          }
          updateCanvas();
        });
      };

      // 状態表示の更新関数
      function updateMaskStatus(selected) {
        const status = document.getElementById("maskStatus");
        status.textContent = selected ? "選択済み" : "未選択";
        status.classList.toggle("selected", selected);
      }

      function updateVideoStatus(selected) {
        const status = document.getElementById("videoStatus");
        status.textContent = selected ? "選択済み" : "未選択";
        status.classList.toggle("selected", selected);
      }

      // ドラッグ＆ドロップの制御
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let startPosX = 0;
      let startPosY = 0;

      canvas.addEventListener("mousedown", (e) => {
        if (!maskImage || !videoElement) return;
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        dragStartX = e.clientX - rect.left;
        dragStartY = e.clientY - rect.top;
        startPosX = posX;
        startPosY = posY;
        canvas.style.cursor = "grabbing";
      });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        posX = startPosX + (x - dragStartX);
        posY = startPosY + (y - dragStartY);

        drawComposite();
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        canvas.style.cursor = "move";
      });

      // スケール制御
      document.getElementById("scale").oninput = (e) => {
        scale = parseFloat(e.target.value);
        document.getElementById("scaleValue").textContent = scale.toFixed(1);
        drawComposite();
      };

      // 録画制御
      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;

      document.getElementById("startRecording").onclick = async () => {
        if (!videoElement || !maskImage) {
          alert("マスク画像と動画を両方セットしてください。");
          return;
        }

        // キャンバスと音声を組み合わせたストリームを作成
        const canvasStream = canvas.captureStream();
        const audioTrack = videoElement.captureStream().getAudioTracks()[0];
        if (audioTrack) {
          canvasStream.addTrack(audioTrack);
        }

        // 録画の準備
        mediaRecorder = new MediaRecorder(canvasStream, {
          mimeType: "video/webm",
        });
        recordedChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "recorded-video.webm";
          a.click();
          URL.revokeObjectURL(url);

          // UI状態を更新
          isRecording = false;
          document.getElementById("startRecording").disabled = false;
          document.getElementById("stopRecording").disabled = true;
          document.getElementById("recordingStatus").textContent = "録画完了";
          document.body.classList.remove("recording");
        };

        // 録画開始
        videoElement.currentTime = 0;
        await videoElement.play();
        mediaRecorder.start();
        isRecording = true;

        // UI状態を更新
        document.getElementById("startRecording").disabled = true;
        document.getElementById("stopRecording").disabled = false;
        document.getElementById("recordingStatus").textContent = "録画中...";
        document.body.classList.add("recording");

        // 動画終了時の処理
        videoElement.onended = () => {
          if (isRecording) {
            mediaRecorder.stop();
            videoElement.onended = null;
          }
        };
      };

      // 手動停止
      document.getElementById("stopRecording").onclick = () => {
        if (isRecording && mediaRecorder) {
          mediaRecorder.stop();
          videoElement.pause();
        }
      };
    </script>
  </body>
</html>
