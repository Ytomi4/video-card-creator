<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Figma プラグイン: マスク画像取得</title>
    <style>
      :root {
        --figma-color-bg: #ffffff;
        --figma-color-bg-secondary: #f5f5f5;
        --figma-color-bg-tertiary: #e5e5e5;
        --figma-color-border: #e0e0e0;
        --figma-color-text: #333333;
        --figma-color-text-secondary: #666666;
        --figma-color-brand: #0d99ff;
        --figma-color-brand-hover: #0a8ae6;
        --figma-radius-small: 2px;
        --figma-radius-med: 6px;
        --figma-space-small: 8px;
        --figma-space-med: 16px;
        --figma-space-large: 24px;
        --figma-color-bg-disabled: rgba(0, 0, 0, 0.05);
        --figma-color-icon: #333333;
        --figma-color-icon-secondary: #666666;
        --figma-color-icon-disabled: rgba(0, 0, 0, 0.3);
      }
      body {
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        margin: 0;
        padding: var(--figma-space-med);
        background: var(--figma-color-bg);
        color: var(--figma-color-text);
        -webkit-font-smoothing: antialiased;
      }
      .section {
        margin-bottom: var(--figma-space-large);
      }
      .materials {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--figma-space-med);
        width: 100%;
        max-width: min(600px, 100vw - 2 * var(--figma-space-med));
        margin: var(--figma-space-med) auto;
        padding: 0 var(--figma-space-small);
        box-sizing: border-box;
      }
      .material-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        padding: var(--figma-space-med);
        border: 1px solid var(--figma-color-border);
        border-radius: var(--figma-radius-med);
        background: var(--figma-color-bg);
        color: var(--figma-color-text);
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        box-sizing: border-box;
        min-width: 0;
      }
      .material-button:hover {
        background: var(--figma-color-bg-secondary);
        border-color: var(--figma-color-text-secondary);
      }
      .controls {
        margin-bottom: var(--figma-space-med);
        background: var(--figma-color-bg-secondary);
        padding: var(--figma-space-small);
        border-radius: var(--figma-radius-med);
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: var(--figma-space-small);
      }
      .control-group label {
        color: var(--figma-color-text-secondary);
        font-size: 12px;
      }
      .control-group input[type="range"] {
        flex: 1;
        height: 2px;
        background: var(--figma-color-border);
        border-radius: var(--figma-radius-small);
      }
      .control-group span {
        font-size: 12px;
        color: var(--figma-color-text-secondary);
        min-width: 32px;
      }
      .canvas-container {
        position: relative;
      }
      #compositePreview {
        display: block;
        margin: 0 auto;
        border: 1px solid var(--figma-color-border);
        border-radius: var(--figma-radius-small);
        background: var(--figma-color-bg-tertiary);
      }
      .canvas-hint {
        position: absolute;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
      }
      .recording-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: var(--figma-space-large);
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .primary-button {
        background: var(--figma-color-bg);
        color: #f24822;
        border: 2px solid #f24822;
        padding: var(--figma-space-small) var(--figma-space-med);
        border-radius: var(--figma-radius-med);
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      .primary-button:hover {
        background: #fff5f2;
        border-color: #d9381e;
      }
      .primary-button:disabled {
        background: var(--figma-color-bg-tertiary);
        color: var(--figma-color-text-secondary);
        border-color: var(--figma-color-border);
        cursor: not-allowed;
      }
      .secondary-button {
        background: var(--figma-color-bg);
        color: var(--figma-color-text);
        border: 1px solid var(--figma-color-border);
        padding: var(--figma-space-small) var(--figma-space-med);
        border-radius: var(--figma-radius-med);
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
      }
      .secondary-button:hover {
        background: var(--figma-color-bg-secondary);
        border-color: var(--figma-color-text-secondary);
      }
      .secondary-button:disabled {
        color: var(--figma-color-text-secondary);
        cursor: not-allowed;
      }
      .status-text {
        color: var(--figma-color-text-secondary);
        font-size: 12px;
      }
      .recording .status-text {
        color: #f44336;
      }
      .preview-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-top: 12px;
      }
      .preview-button {
        width: 32px;
        height: 32px;
        padding: 4px;
        border: 1px solid var(--figma-color-border);
        border-radius: var(--figma-radius-small);
        background: transparent;
        color: var(--figma-color-icon);
        cursor: pointer;
        transition: all 0.1s ease;
      }
      .preview-button:hover:not(:disabled) {
        background: var(--figma-color-bg-secondary);
        border-color: var(--figma-color-text-secondary);
      }
      .preview-button:disabled {
        color: var(--figma-color-icon-disabled);
        background: var(--figma-color-bg-disabled);
        cursor: not-allowed;
      }
      .preview-button svg {
        width: 24px;
        height: 24px;
      }
    </style>
  </head>
  <body>
    <div class="section">
      <div class="materials">
        <button id="getMaskImage" class="material-button">
          <span>フレームを選択</span>
        </button>
        <label
          class="material-button"
          for="videoUpload"
          style="cursor: pointer"
        >
          <span>動画を選択</span>
        </label>
        <input
          type="file"
          id="videoUpload"
          accept="video/webm,video/mp4"
          hidden
        />
      </div>
    </div>

    <div class="section">
      <div class="controls">
        <div class="control-group">
          <label>スケール: </label>
          <input
            type="range"
            id="scale"
            min="0.1"
            max="2"
            step="0.1"
            value="1"
          />
          <span id="scaleValue">1.0</span>
        </div>
      </div>
      <div class="canvas-container">
        <canvas id="compositePreview"></canvas>
      </div>
      <div class="preview-controls">
        <button
          id="resetVideo"
          class="preview-button"
          disabled
          title="最初から"
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"
              fill="currentColor"
            />
          </svg>
        </button>
        <button
          id="playVideo"
          class="preview-button"
          disabled
          title="再生/一時停止"
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M8 5v14l11-7z" fill="currentColor" />
          </svg>
        </button>
      </div>
    </div>

    <div class="section">
      <div class="recording-controls">
        <button id="startRecording" class="primary-button" title="録画開始">
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <circle cx="10" cy="10" r="7" fill="#F24822" />
          </svg>
        </button>
        <button
          id="stopRecording"
          class="secondary-button"
          disabled
          title="録画停止"
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <rect x="5" y="5" width="10" height="10" rx="2" fill="#333" />
          </svg>
        </button>
        <div id="recordingStatus" class="status-text"></div>
      </div>
    </div>

    <script>
      // マスク画像取得
      document.getElementById("getMaskImage").onclick = () => {
        parent.postMessage({ pluginMessage: { type: "get-mask-image" } }, "*");
      };
      // Figmaからのメッセージ処理
      window.onmessage = (event) => {
        const msg = event.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "mask-image") {
          const blob = new Blob([new Uint8Array(msg.data)], {
            type: "image/png",
          });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.onload = () => {
            maskImage = img;
            updateMaskStatus(true);
            updateCanvasSize();
          };
          img.src = url;
        } else if (msg.type === "error") {
          alert(msg.message);
        }
      };

      // 合成プレビューの状態管理
      let maskImage = null;
      let videoElement = null;
      const canvas = document.getElementById("compositePreview");
      const ctx = canvas.getContext("2d");
      let posX = 0;
      let posY = 0;
      let scale = 1;

      // キャンバスサイズの設定
      function updateCanvasSize() {
        if (!maskImage) return;
        canvas.width = maskImage.width;
        canvas.height = maskImage.height;
        drawComposite();
      }

      // 合成描画
      function drawComposite() {
        // キャンバスが初期化されていない場合は初期化
        if (!canvas.width || !canvas.height) {
          if (maskImage) {
            canvas.width = maskImage.width;
            canvas.height = maskImage.height;
          } else if (videoElement) {
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
          } else {
            return; // どちらの素材もない場合は何もしない
          }
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 下層に動画を描画（もしあれば）
        if (videoElement && videoElement.readyState >= 2) {
          // HAVE_CURRENT_DATA以上
          ctx.save();
          ctx.translate(posX, posY);
          ctx.scale(scale, scale);
          ctx.drawImage(videoElement, 0, 0);
          ctx.restore();
        }

        // 上層にマスク画像を描画（もしあれば）
        if (maskImage) {
          ctx.drawImage(maskImage, 0, 0);
        }
      }

      // プレビューコントロールの更新
      function updatePreviewControls() {
        const playButton = document.getElementById("playVideo");
        const resetButton = document.getElementById("resetVideo");
        const hasVideo = videoElement != null;

        playButton.disabled = !hasVideo;
        resetButton.disabled = !hasVideo;

        // 再生/一時停止アイコンの更新
        if (hasVideo && !videoElement.paused) {
          playButton.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" fill="currentColor"/>
            </svg>
          `;
          playButton.title = "一時停止";
        } else {
          playButton.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 5v14l11-7z" fill="currentColor"/>
            </svg>
          `;
          playButton.title = "再生";
        }
      }

      // 動画ファイルアップロード処理
      document.getElementById("videoUpload").onchange = (event) => {
        const file = event.target.files[0];
        if (!file) {
          updateVideoStatus(false);
          videoElement = null;
          updatePreviewControls();
          return;
        }

        // 動画ファイルの形式チェック
        if (!file.type.match(/^video\/(webm|mp4)$/)) {
          alert("WebMまたはMP4形式の動画ファイルを選択してください。");
          updateVideoStatus(false);
          updatePreviewControls();
          return;
        }

        const url = URL.createObjectURL(file);
        const video = document.createElement("video");
        video.src = url;

        // 必要な属性を設定
        video.autoplay = false;
        video.loop = true;
        video.muted = true;

        // 合成プレビュー用の参照を保存
        videoElement = video;

        // メタデータ読み込み完了時の処理
        video.onloadeddata = async () => {
          updateVideoStatus(true);
          updatePreviewControls();
          // 最初のフレームを表示するために一時的に再生
          await video.play();
          video.pause();
          drawComposite();
        };

        // 再生状態変更時の処理
        video.addEventListener("play", () => {
          updatePreviewControls();
        });

        video.addEventListener("pause", () => {
          updatePreviewControls();
        });

        // 再生時の更新処理
        video.addEventListener("play", () => {
          function updateCanvas() {
            if (!video.paused && !video.ended) {
              drawComposite();
              requestAnimationFrame(updateCanvas);
            }
          }
          updateCanvas();
        });
      };

      // 状態表示の更新関数
      function updateMaskStatus(selected) {
        // ステータス表示要素が削除されたため、何もしない
        // 必要に応じて他の視覚的フィードバックを追加可能
      }

      function updateVideoStatus(selected) {
        // ステータス表示要素が削除されたため、何もしない
        // 必要に応じて他の視覚的フィードバックを追加可能
      }

      // ドラッグ＆ドロップの制御
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let startPosX = 0;
      let startPosY = 0;

      canvas.addEventListener("mousedown", (e) => {
        if (!maskImage || !videoElement) return;
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        dragStartX = e.clientX - rect.left;
        dragStartY = e.clientY - rect.top;
        startPosX = posX;
        startPosY = posY;
        canvas.style.cursor = "grabbing";
      });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        posX = startPosX + (x - dragStartX);
        posY = startPosY + (y - dragStartY);

        drawComposite();
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        canvas.style.cursor = "move";
      });

      // スケール制御
      document.getElementById("scale").oninput = (e) => {
        scale = parseFloat(e.target.value);
        document.getElementById("scaleValue").textContent = scale.toFixed(1);
        drawComposite();
      };

      // プレビュー用の動画コントロール
      document.getElementById("playVideo").onclick = async () => {
        if (!videoElement) return;

        if (videoElement.paused) {
          await videoElement.play();
        } else {
          videoElement.pause();
        }
        updatePreviewControls();
      };

      document.getElementById("resetVideo").onclick = () => {
        if (!videoElement) return;

        videoElement.currentTime = 0;
        drawComposite();
      };

      // 録画制御
      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;

      document.getElementById("startRecording").onclick = async () => {
        if (!videoElement || !maskImage) {
          alert("マスク画像と動画を両方セットしてください。");
          return;
        }

        // キャンバスと音声を組み合わせたストリームを作成
        const canvasStream = canvas.captureStream();
        const audioTrack = videoElement.captureStream().getAudioTracks()[0];
        if (audioTrack) {
          canvasStream.addTrack(audioTrack);
        }

        // 録画の準備
        mediaRecorder = new MediaRecorder(canvasStream, {
          mimeType: "video/webm",
        });
        recordedChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: "video/webm" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "recorded-video.webm";
          a.click();
          URL.revokeObjectURL(url);

          // UI状態を更新
          isRecording = false;
          document.getElementById("startRecording").disabled = false;
          document.getElementById("stopRecording").disabled = true;
          document.getElementById("recordingStatus").textContent = "録画完了";
          document.body.classList.remove("recording");
        };

        // 録画開始前の準備
        videoElement.loop = false; // 録画時はループを無効化
        videoElement.currentTime = 0;

        // 動画終了時の処理を設定
        const handleVideoEnd = () => {
          if (isRecording) {
            mediaRecorder.stop();
            videoElement.removeEventListener("ended", handleVideoEnd);
            videoElement.loop = true; // プレビュー用のループを再有効化
          }
        };
        videoElement.addEventListener("ended", handleVideoEnd);

        // 録画開始
        await videoElement.play();
        mediaRecorder.start();
        isRecording = true;

        // UI状態を更新
        document.getElementById("startRecording").disabled = true;
        document.getElementById("stopRecording").disabled = false;
        document.getElementById("recordingStatus").textContent = "録画中...";
        document.body.classList.add("recording");
      };

      // 手動停止
      document.getElementById("stopRecording").onclick = () => {
        if (isRecording && mediaRecorder) {
          mediaRecorder.stop();
          videoElement.pause();
        }
      };
    </script>
  </body>
</html>
